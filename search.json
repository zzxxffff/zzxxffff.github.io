[{"title":"面向对象","url":"/2023/04/08/c++/c++/","content":"\n\n简述：\n完成对面向对象的笔记\n<!--more-->\n\n## c++\n\n## 面向对象 -- 上\n\n目标：培养良好的编程习惯\n\n良好的方式编写class \n\n带指针和不带指针的类\n---learn m\n基于对象 类\n\n面向对象 封装 继承 多态\n\n\n\n\n历史：\n\n建立在c语言之上\n\nnew c --》c with class -》c++\n\n演化：\n\nc++98 （1.0）\n\nc++11 （2.0）\n\n语言+标准库\n\n\n\n数据和函数包在一起 --》class struct --》创建很多objects\n\n不带指针的 --》复数\n\n带指针的 --》字符串\n\n\n\n基于对象\n\nclass without pointer --》complex\n\n\n\n\n\nc++代码的基本形式：\n\n头文件\n\n主程序\n\n标准库\n\n\n\n\n\n文件的拓展名不重要\n\n\n\nc++输出\n\n\n\n## 标准库\n\n泛型编程 --> template \n\n\n\n使用c++标准库\n\n认识c++标准库\n\n良好使用c++标准库\n\n拓展c++标准库\n\n\n\n\n\n标准库 > stl库\n\n标准库以头文件形式呈现 \n\nc++头文件不带 .h\n\n新版c的库也不带 .h 改为cmath\n\n旧的形式仍然可以使用\n\n\n\n命名空间 一般标准库都封装在std名称空间中 在使用时需要使用全称\n\n可以简化 using namespace std;\n\n\n\nstl的体系结构：\n\n六大组件：\n\n容器 containers  == 数据结构  \n\n--》看不到内存的事情 需要分配器来支持他 \n\n操作：函数 算法来操作容器 \n\n设计方法与oop的思想是不一样的  --》泛型编程 模板编程\n\n容器--》数据\n\n算法--》操作\n\n桥梁--》迭代器 泛化的指针\n\n\n\n分配器 allocators ：为容器分配内存空间\n\n算法 algorithms\n\n迭代器 iterators\n\n适配器 adapters 执行转换功能\n\n仿函数 functors 作用像是一个函数，执行操作\n\n![image-20230310200907136](C:\\Users\\zxf\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230310200907136.png)\n\n程序=数据结构+算法\n\n分配器作为容器模板的一个参数，可以不写，默认自带\n\n容器和分配器的类型要匹配\n\n![image-20230310203047791](C:\\Users\\zxf\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230310203047791.png)\n\n\n\n\n\n算法复杂度：大O表示法\n\n其中的n必须很大很大 才能展现出复杂度等级\n\n\n\n区间：\n\n容器 ： 左闭右开区间\n\nbegin指向第一个元素\n\nend指向最后的元素的下一个位置\n\n![image-20230310203709854](C:\\Users\\zxf\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230310203709854.png)\n\niterator 泛化的指针 能做很多事情\n\n![image-20230310204259123](C:\\Users\\zxf\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230310204259123.png)\n\n![image-20230310204518838](C:\\Users\\zxf\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230310204518838.png)\n\n### 容器\n\n结构+分类\n\nsequence containers\n\n1. array 数组包装成class 无法扩充\n2. vector 从最后可以扩充 空间自动增长  （分配器的作用） --》栈\n3. deque 双向队列 两端可进可出 \n4. list 双向链表 \n5. forward-list 单向链表 比list的空间少 指针的空间\n\nassociative containers --》查找非常快 -- 》红黑树（高度平衡树）\n\n1. set  不分key value\n2. map 结点是key value\n3. multiset\n4. multimap\n\n放置的东西不是独一无二的，就不能用set map\n\n（unordered containers 所属上边类型  无序，无组织） --》散列表\n\n\n\n![image-20230310210030871](C:\\Users\\zxf\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230310210030871.png)\n\n\n\n![image-20230310210730294](C:\\Users\\zxf\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230310210730294.png)\n\n容器的效率\n\n```c++\n//获取一个目标值\nlong get_a_target()\n{\n\tlong target = 0;\n\tcout << \" target(0 - \" << RAND_MAX << \"):\";\n\tcin >> target;\n\treturn target;\n}\n\n//将目标值以字符串形式返回\nstring get_a_target()\n{\n\tlong target = 0;\n\tchar buf[10];\n\tcout << \" target(0 - \" << RAND_MAX << \"):\";\n\tcin >> target;\n\t\n\tsnprintf(buf,10,\"%d\",target); //将其转换为字符串\n\treturn string(buf);\n}\n\nint compareLongs(const void*a,const void*b)\n{\n\treturn (*(long*)a - *(long*)b )\n}\n\nint compareLongs(const void*a,const void*b)\n{\n\tif(*(string*)a > *(string*)b ) return 1;\n\telse if (*(string*)a < *(string*)b ) return -1;\n\telse reuturn 0;\n}\n```\n\n\n\n```\n//使用array容器\n//array 一定要有第二个参数，定义大小，只能是常数\narray<long,1000> c;\nfor(long i =0; i < 1000; i++)\n{\n\tc[i] = rand();\n}\n```\n\n\n\n---\n\n# end","tags":["aaa"]},{"title":"设计模式","url":"/2023/04/08/c++/设计模式/","content":"\n\n简述：完成对设计模式的分解\n<!--more-->\n\n### 设计模式\n\n## 什么是设计模式？\n\n将常见的问题统一成一致的解决方式，不需要再去造轮子；\n\n设计模式：可复用面向对象软件\n\n面向对象的设计模式：\n\n面向对象：\n\n底层思维：向下，把握机器底层的对象构造\n\n1. 编译\n2. 内存\n3. 运行的机制\n4. 语言构造\n\n抽象思维：向上，将现实世界抽象为程序代码\n\n1. 面向对象\n2. 组件封装\n3. 设计模式\n4. 架构模式\n\n更好的管理代码\n\n\n\n## 面向对象\n\n向下：\n\n封装：隐藏内部细节\n\n继承：代码复用\n\n多态：动态绑定，改写对象的行为\n\n向上：\n\n理解面向对象的抽象，理解如何使用机制来表达现实世界\n\n\n\n软件设计固有的复杂性：\n\n需求的变更，导致对软件的冲击\n\n变化\n\n解决复杂性：\n\n分解：分而治之\n\n**抽象**\n\n\n\n提升复用性\n\n\n\n好的软件设计：复用\n\n\n\n\n\n面向对象的优势：抵御变化\n\n隔离变化，将变化的影响降到最小\n\n各司其职，不影响原来的代码实现\n\n\n\n\n\n## 面向对象的设计原则\n\n### \n\n设计模式依赖设计原则来实现\n\n### 依赖倒置原则 DIP\n\n高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）\n\n抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象\n\n稳定依赖稳定，不稳定依赖稳定\n\n### 开放封闭原则 OCP\n\n对拓展开放，对修改封闭\n\n类模块可拓展，但是不能修改\n\n### 单一职责原则 SRP\n\n一个类应该只有一个引起它变化的原因\n\n变化的方向隐含着类的**责任**\n\n类不要太臃肿，不能含有多个责任\n\n### Liskov替换原则 LSP\n\n子类必须能够替换基类\n\n### 接口隔离原则 ISP\n\n接口应该小而完备\n\n不应该强迫程序使用不需要的方法\n\n### 优先使用对象组合，而不是类继承\n\n类继承：白箱复用\n\n对象组合：黑箱复用\n\n继承某种程度上破坏了封装性，子类父类耦合度高\n\n对象组合只要求被组合对象具有良好定义的接口\n\n### 封装变化点\n\n使用封装来创建对象之间的分界层，一侧变化，一侧稳定\n\n### 针对接口编程，而不是针对实现编程\n\n不将变量类型声明为某个特定的具体类，而是声明为某个接口。\n\n客户程序无需获知对象的具体类型，只需要知道接口\n\n减少系统各部分的依赖关系，实现高内聚松耦合\n\n\n\n\n\n==》面向接口设计：接口标准化-->产业强盛\n\n将设计原则提升为设计经验\n\n1. 设计习语 描述与特定编程语言相关的低层模式\n2. 设计模式 类与相互通信的对象之间的组织关系 --》变化中的复用\n3. 架构模式 描述系统中与基本结构组织关系密切的高层模式\n\n\n\n设计模式分类：\n\n目的：\n\n1. 创建型 对象的创建等\n2. 结构型 应对需求变化对结构的冲击\n3. 行为型 对象与对象之间的职责\n\n实现手段：\n\n1. 类模式 处理类和子类的静态关系 继承\n2. 对象模式 对象间的动态关系 对象包含\n\n\n\n好的面向对象设计：应对变化，提高复用\n\n--》寻找变化点，在变化点处应用设计模式\n\n重要的是理解什么时候什么地点应用设计模式\n\n敏捷软件开发提倡重构对象模式\n\n\n\n重构关键方法：\n\n静态-》动态\n\n早绑定-》晚绑定\n\n继承-》对象组合\n\n编译时依赖-》运行时依赖\n\n紧耦合-》松耦合\n\n\n\n\n\n## 组件协作模式\n\n软件专业分工导致的结果就是“框架和应用”该模式通过晚期绑定，实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式\n\n典型模式：\n\ntemplate method\n\nstrategy\n\nobserver/event\n\n\n\n#### 模板方法 template method\n\n![image-20230330153325991](C:\\Users\\zxf\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230330153325991.png)\n\n \n\n早绑定：library创建功能，app调用library里的功能\n\n晚绑定：将函数调用流程创建在library中，让其中的某些实现在app中完成\n\n![image-20230330193938805](C:\\Users\\zxf\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230330193938805.png)\n\n\n\n假定所有功能都是稳定的，设计模式也就没有必要存在了，变化同理\n\n\n\n核心在于分辨出什么是稳定的，什么是变化的\n\n![image-20230330194513174](C:\\Users\\zxf\\Desktop\\image-20230330194513174.png)\n\n\n\n![image-20230330194543931](C:\\Users\\zxf\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230330194543931.png)\n\n\n\n拓展：继承+虚函数（重写）\n\n思考变化和稳定的关系\n\n\n\n#### 策略模式\n\n某些对象使用的算法多种多样，经常改变\n\n对拓展开放，对修改封闭 --》违背开闭原则\n\n将算法编程各种的子类\n\n","categories":["页面","CSS","xioa"]}]