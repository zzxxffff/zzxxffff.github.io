{"meta":{"title":"hi~bro~","subtitle":"热爱动手，热爱一切","description":"","author":"Oak-Bonus","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-04-08T02:17:31.439Z","updated":"2023-04-08T02:17:31.439Z","comments":true,"path":"README.html","permalink":"http://example.com/README.html","excerpt":"","text":"zhege shenm"},{"title":"about","date":"2023-04-08T04:12:50.000Z","updated":"2023-04-08T04:12:50.874Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"你好这个是第一页"},{"title":"tags","date":"2023-04-08T03:26:21.000Z","updated":"2023-04-08T03:28:32.100Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":"你好这个是第一页"},{"title":"categories","date":"2023-04-08T07:40:41.000Z","updated":"2023-04-08T07:40:41.298Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":"你好这个是第一页"}],"posts":[{"title":"面向对象","slug":"c++/c++","date":"2023-04-07T16:00:00.000Z","updated":"2023-04-08T07:39:35.308Z","comments":true,"path":"2023/04/08/c++/c++/","link":"","permalink":"http://example.com/2023/04/08/c++/c++/","excerpt":"简述： 完成对面向对象的笔记","text":"简述： 完成对面向对象的笔记 c++ 面向对象 – 上 目标：培养良好的编程习惯 良好的方式编写class 带指针和不带指针的类 —learn m 基于对象 类 面向对象 封装 继承 多态 历史： 建立在c语言之上 new c --》c with class -》c++ 演化： c++98 （1.0） c++11 （2.0） 语言+标准库 数据和函数包在一起 --》class struct --》创建很多objects 不带指针的 --》复数 带指针的 --》字符串 基于对象 class without pointer --》complex c++代码的基本形式： 头文件 主程序 标准库 文件的拓展名不重要 c++输出 标准库 泛型编程 --&gt; template 使用c++标准库 认识c++标准库 良好使用c++标准库 拓展c++标准库 标准库 &gt; stl库 标准库以头文件形式呈现 c++头文件不带 .h 新版c的库也不带 .h 改为cmath 旧的形式仍然可以使用 命名空间 一般标准库都封装在std名称空间中 在使用时需要使用全称 可以简化 using namespace std; stl的体系结构： 六大组件： 容器 containers == 数据结构 –》看不到内存的事情 需要分配器来支持他 操作：函数 算法来操作容器 设计方法与oop的思想是不一样的 --》泛型编程 模板编程 容器–》数据 算法–》操作 桥梁–》迭代器 泛化的指针 分配器 allocators ：为容器分配内存空间 算法 algorithms 迭代器 iterators 适配器 adapters 执行转换功能 仿函数 functors 作用像是一个函数，执行操作 程序=数据结构+算法 分配器作为容器模板的一个参数，可以不写，默认自带 容器和分配器的类型要匹配 算法复杂度：大O表示法 其中的n必须很大很大 才能展现出复杂度等级 区间： 容器 ： 左闭右开区间 begin指向第一个元素 end指向最后的元素的下一个位置 iterator 泛化的指针 能做很多事情 容器 结构+分类 sequence containers array 数组包装成class 无法扩充 vector 从最后可以扩充 空间自动增长 （分配器的作用） --》栈 deque 双向队列 两端可进可出 list 双向链表 forward-list 单向链表 比list的空间少 指针的空间 associative containers --》查找非常快 – 》红黑树（高度平衡树） set 不分key value map 结点是key value multiset multimap 放置的东西不是独一无二的，就不能用set map （unordered containers 所属上边类型 无序，无组织） --》散列表 容器的效率 1234567891011121314151617181920212223242526272829303132//获取一个目标值long get_a_target()&#123; long target = 0; cout &lt;&lt; &quot; target(0 - &quot; &lt;&lt; RAND_MAX &lt;&lt; &quot;):&quot;; cin &gt;&gt; target; return target;&#125;//将目标值以字符串形式返回string get_a_target()&#123; long target = 0; char buf[10]; cout &lt;&lt; &quot; target(0 - &quot; &lt;&lt; RAND_MAX &lt;&lt; &quot;):&quot;; cin &gt;&gt; target; snprintf(buf,10,&quot;%d&quot;,target); //将其转换为字符串 return string(buf);&#125;int compareLongs(const void*a,const void*b)&#123; return (*(long*)a - *(long*)b )&#125;int compareLongs(const void*a,const void*b)&#123; if(*(string*)a &gt; *(string*)b ) return 1; else if (*(string*)a &lt; *(string*)b ) return -1; else reuturn 0;&#125; 1234567//使用array容器//array 一定要有第二个参数，定义大小，只能是常数array&lt;long,1000&gt; c;for(long i =0; i &lt; 1000; i++)&#123; c[i] = rand();&#125; end","categories":[],"tags":[{"name":"aaa","slug":"aaa","permalink":"http://example.com/tags/aaa/"}]},{"title":"设计模式","slug":"c++/设计模式","date":"2023-04-07T16:00:00.000Z","updated":"2023-04-08T07:41:55.207Z","comments":true,"path":"2023/04/08/c++/设计模式/","link":"","permalink":"http://example.com/2023/04/08/c++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"简述：完成对设计模式的分解","text":"简述：完成对设计模式的分解 设计模式 什么是设计模式？ 将常见的问题统一成一致的解决方式，不需要再去造轮子； 设计模式：可复用面向对象软件 面向对象的设计模式： 面向对象： 底层思维：向下，把握机器底层的对象构造 编译 内存 运行的机制 语言构造 抽象思维：向上，将现实世界抽象为程序代码 面向对象 组件封装 设计模式 架构模式 更好的管理代码 面向对象 向下： 封装：隐藏内部细节 继承：代码复用 多态：动态绑定，改写对象的行为 向上： 理解面向对象的抽象，理解如何使用机制来表达现实世界 软件设计固有的复杂性： 需求的变更，导致对软件的冲击 变化 解决复杂性： 分解：分而治之 抽象 提升复用性 好的软件设计：复用 面向对象的优势：抵御变化 隔离变化，将变化的影响降到最小 各司其职，不影响原来的代码实现 面向对象的设计原则 设计模式依赖设计原则来实现 依赖倒置原则 DIP 高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定） 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象 稳定依赖稳定，不稳定依赖稳定 开放封闭原则 OCP 对拓展开放，对修改封闭 类模块可拓展，但是不能修改 单一职责原则 SRP 一个类应该只有一个引起它变化的原因 变化的方向隐含着类的责任 类不要太臃肿，不能含有多个责任 Liskov替换原则 LSP 子类必须能够替换基类 接口隔离原则 ISP 接口应该小而完备 不应该强迫程序使用不需要的方法 优先使用对象组合，而不是类继承 类继承：白箱复用 对象组合：黑箱复用 继承某种程度上破坏了封装性，子类父类耦合度高 对象组合只要求被组合对象具有良好定义的接口 封装变化点 使用封装来创建对象之间的分界层，一侧变化，一侧稳定 针对接口编程，而不是针对实现编程 不将变量类型声明为某个特定的具体类，而是声明为某个接口。 客户程序无需获知对象的具体类型，只需要知道接口 减少系统各部分的依赖关系，实现高内聚松耦合 ==》面向接口设计：接口标准化–&gt;产业强盛 将设计原则提升为设计经验 设计习语 描述与特定编程语言相关的低层模式 设计模式 类与相互通信的对象之间的组织关系 --》变化中的复用 架构模式 描述系统中与基本结构组织关系密切的高层模式 设计模式分类： 目的： 创建型 对象的创建等 结构型 应对需求变化对结构的冲击 行为型 对象与对象之间的职责 实现手段： 类模式 处理类和子类的静态关系 继承 对象模式 对象间的动态关系 对象包含 好的面向对象设计：应对变化，提高复用 –》寻找变化点，在变化点处应用设计模式 重要的是理解什么时候什么地点应用设计模式 敏捷软件开发提倡重构对象模式 重构关键方法： 静态-》动态 早绑定-》晚绑定 继承-》对象组合 编译时依赖-》运行时依赖 紧耦合-》松耦合 组件协作模式 软件专业分工导致的结果就是“框架和应用”该模式通过晚期绑定，实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式 典型模式： template method strategy observer/event 模板方法 template method 早绑定：library创建功能，app调用library里的功能 晚绑定：将函数调用流程创建在library中，让其中的某些实现在app中完成 假定所有功能都是稳定的，设计模式也就没有必要存在了，变化同理 核心在于分辨出什么是稳定的，什么是变化的 拓展：继承+虚函数（重写） 思考变化和稳定的关系 策略模式 某些对象使用的算法多种多样，经常改变 对拓展开放，对修改封闭 --》违背开闭原则 将算法编程各种的子类","categories":[{"name":"页面","slug":"页面","permalink":"http://example.com/categories/%E9%A1%B5%E9%9D%A2/"},{"name":"CSS","slug":"页面/CSS","permalink":"http://example.com/categories/%E9%A1%B5%E9%9D%A2/CSS/"},{"name":"xioa","slug":"页面/CSS/xioa","permalink":"http://example.com/categories/%E9%A1%B5%E9%9D%A2/CSS/xioa/"}],"tags":[]}],"categories":[{"name":"页面","slug":"页面","permalink":"http://example.com/categories/%E9%A1%B5%E9%9D%A2/"},{"name":"CSS","slug":"页面/CSS","permalink":"http://example.com/categories/%E9%A1%B5%E9%9D%A2/CSS/"},{"name":"xioa","slug":"页面/CSS/xioa","permalink":"http://example.com/categories/%E9%A1%B5%E9%9D%A2/CSS/xioa/"}],"tags":[{"name":"aaa","slug":"aaa","permalink":"http://example.com/tags/aaa/"}]}